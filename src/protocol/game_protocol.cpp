/*

  Copyright [2024-2025] [Leonardo Julca]

  Permission is hereby granted, free of charge, to any person obtaining
  a copy of this software and associated documentation files (the
  "Software"), to deal in the Software without restriction, including
  without limitation the rights to use, copy, modify, merge, publish,
  distribute, sublicense, and/or sell copies of the Software, and to
  permit persons to whom the Software is furnished to do so, subject to
  the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

 */

/*

   Copyright [2010] [Josko Nikolic]

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   CODE PORTED FROM THE ORIGINAL GHOST PROJECT

 */

#include <utility>

#include "game_protocol.h"
#include <crc32/crc32.h>
#include "../util.h"
#include "../file_util.h"
#include "../game_user.h"
#include "../game_slot.h"
#include "../game_stat.h"
#include "../game.h"

using namespace std;

namespace GameProtocol
{
  const vector<uint8_t>& GetEmptyAction()
  {
    return EmptyAction;
  }

  bitset<256> InitActionCountables()
  {
    bitset<256> countables;
    countables.set(ACTION_ABILITY_TARGET_NONE);
    countables.set(ACTION_ABILITY_TARGET_POINT);
    countables.set(ACTION_ABILITY_TARGET_OBJECT);
    countables.set(ACTION_GIVE_OR_DROP_ITEM);
    countables.set(ACTION_ABILITY_TARGET_FOG);
    countables.set(ACTION_ABILITY_TARGET_FOG_HANDLE); // patch to APM spec
    countables.set(ACTION_GROUP_HOTKEY_ASSIGN);
    countables.set(ACTION_GROUP_HOTKEY_SELECT);
    // ACTION_SELECTION_SUBGROUP - "Nearly all 'Select Subgroup' actions are autogenerated."
    countables.set(ACTION_SELECTION_GROUND_ITEM);
    countables.set(ACTION_CANCEL_REVIVAL);
    countables.set(ACTION_CANCEL_TRAINING);
    countables.set(ACTION_ESCAPE);
    countables.set(ACTION_BUILDMENU);
    // ACTION_MODAL_BTN - excluded by APM spec by blue, nagger
    return countables;
  }

  bool GetActionIsCountable(uint8_t actionType)
  {
    return ActionCountables.test(actionType);
  }

  const array<uint8_t, 256>& GetActionSizes()
  {
    return ActionSizes;
  }

  size_t GetActionSize(uint8_t actionType)
  {
    return ActionSizes[actionType];
  }

  size_t GetNextActionPosCacheUnitInner(const vector<uint8_t>& /*action*/, size_t actionStartPos, size_t /*cacheUnitStartPos*/)
  {
    // TODO: ACTION_GAME_CACHE_UNIT
    return actionStartPos;
  }

  size_t GetNextActionPos(const vector<uint8_t>& action, size_t pos)
  {
    switch (action[pos]) {
      case ACTION_SAVE: {
        // <0x06 cstring>
        size_t messageStart = pos + 1;
        size_t messageEnd = FindNullDelimiterOrStart(action, messageStart);
        if (messageEnd == messageStart) return pos;
        return messageEnd + 1;
      }
      case ACTION_SELECTION: // 0x16
      case ACTION_GROUP_HOTKEY_ASSIGN: // 0x17
        //if (action.size() <= pos + 2) return pos;
        return pos + 4 + 8 * action[pos + 2];
      case ACTION_CHAT_TRIGGER: {
        // <0x60 dword dword cstring>
        size_t messageStart = pos + 9;
        size_t messageEnd = FindNullDelimiterOrStart(action, messageStart);
        if (messageEnd == messageStart) return pos;
        return messageEnd + 1;
      }
      case ACTION_ALLIANCE_SETTINGS: { // 0x50
        if (action[pos + 1] == JN_ALLIANCE_SETTINGS_SYNC_DATA) return action.size();
        if (action[pos + 1] == MH_DOTA_SETTINGS_SYNC_DATA) return pos + 6 + ByteArrayToUInt32(action, false, pos + 2);
        return pos + 6;
      }
      case ACTION_GAME_CACHE_INT: // 0x6B
      case ACTION_GAME_CACHE_REAL: // 0x6C
      case ACTION_GAME_CACHE_BOOL: // 0x6D
      case ACTION_GAME_CACHE_UNIT: // 0x6E
      case ACTION_GAME_CACHE_STRING: // 0x6F
      case ACTION_GAME_CACHE_CLEAR_INT: // 0x70
      case ACTION_GAME_CACHE_CLEAR_REAL: // 0x71
      case ACTION_GAME_CACHE_CLEAR_BOOL: // 0x72
      case ACTION_GAME_CACHE_CLEAR_UNIT: // 0x73
      case ACTION_GAME_CACHE_CLEAR_STRING: { // 0x74
        size_t stringStart, stringEnd;
        stringStart = pos + 1;
        stringEnd = FindNullDelimiterOrStart(action, stringStart); // end cache file name
        if (stringEnd == stringStart) return pos;
        stringStart = stringEnd + 1;
        stringEnd = FindNullDelimiterOrStart(action, stringStart); // end mission key
        if (stringEnd == stringStart) return pos;
        stringStart = stringEnd + 1;
        stringEnd = FindNullDelimiterOrStart(action, stringStart); // end key
        if (stringEnd == stringStart) return pos;
        if (action[pos] < ACTION_GAME_CACHE_UNIT) {
          return stringEnd + 5; // end value (1 byte is null delimiter, 4 bytes are uint32_t)
        } else if (action[pos] == ACTION_GAME_CACHE_UNIT) {
          return GetNextActionPosCacheUnitInner(action, pos, stringEnd + 1);
        } else if (action[pos] == ACTION_GAME_CACHE_STRING) {
          stringStart = stringEnd + 1;
          stringEnd = FindNullDelimiterOrStart(action, stringStart); // end key
          if (stringEnd == stringStart) return pos;
          return stringEnd + 1; // end value (1 byte is null delimiter)
        } else {
          return stringEnd + 1; // end value (1 byte is null delimiter)
        }
      }

      case ACTION_W3API: { // 0x77
        return pos + 13 + ByteArrayToUInt32(action, false, pos + 9);
      }

      case ACTION_SYNCHRONIZE: { // 0x78
        size_t stringStart, stringEnd;
        stringStart = pos + 1;
        stringEnd = FindNullDelimiterOrStart(action, stringStart); // ??
        if (stringEnd == stringStart) return pos;
        stringStart = stringEnd + 1;
        stringEnd = FindNullDelimiterOrStart(action, stringStart); // ??
        if (stringEnd == stringStart) return pos;
        return stringEnd + 5; // end value (1 byte is null delimiter, 4 bytes are uint32_t)
      }
      default:
        return pos + ActionSizes[action[pos]];
    }
  }

  PacketWrapper::PacketWrapper(const std::vector<uint8_t>& nData, const size_t nCount)
  : count(nCount),
    data(nData)
  {
  };

  PacketWrapper::~PacketWrapper()
  {
  };

  void PacketWrapper::Remove(size_t removeCount)
  {
    size_t cursor = 0;
    removeCount = min(removeCount, count);
    while (0 < removeCount && cursor + 4 <= data.size()) {
      assert((data[cursor] == GameProtocol::Magic::W3GS_HEADER) && "PacketWrapper should only contain W3GS packets.");
      size_t thisSize = ByteArrayToUInt16(data, false, cursor + 2);
      assert(thisSize >= 4 && "PacketWrapper should only contain valid-sized W3GS packets.");
      cursor += thisSize;
    }
    data.erase(data.begin(), data.begin() + cursor);
  }

  ///////////////////////
  // RECEIVE FUNCTIONS //
  ///////////////////////

  CIncomingJoinRequest RECEIVE_W3GS_REQJOIN(const std::vector<uint8_t>& data)
  {
    // DEBUG_Print( "RECEIVED W3GS_REQJOIN" );
    // DEBUG_Print( data );

    // 2 bytes                    -> Header
    // 2 bytes                    -> Length
    // 4 bytes                    -> Host Counter (Game ID)
    // 4 bytes                    -> Entry Key (used in LAN)
    // 1 byte                     -> ???
    // 2 bytes                    -> Listen Port
    // 4 bytes                    -> Peer Key
    // null terminated string			-> Name
    // 4 bytes                    -> ???
    // 2 bytes                    -> InternalPort (???)
    // 4 bytes                    -> InternalIP

    if (ValidateLength(data) && data.size() >= 20) {
      const uint32_t             HostCounter = ByteArrayToUInt32(data, false, 4);
      const uint32_t             EntryKey    = ByteArrayToUInt32(data, false, 8);
      const std::vector<uint8_t> RawName     = ExtractCString(data, 19);

      if (!RawName.empty() && data.size() >= RawName.size() + 30) {
        std::array<uint8_t, 4> InternalIP = {0, 0, 0, 0};
        copy_n(data.begin() + RawName.size() + 26, 4, InternalIP.begin());
        return CIncomingJoinRequest(HostCounter, EntryKey, string(begin(RawName), end(RawName)), InternalIP);
      }
    }

    return CIncomingJoinRequest();
  }

  uint32_t RECEIVE_W3GS_LEAVEGAME(const std::vector<uint8_t>& data)
  {
    // DEBUG_Print( "RECEIVED W3GS_LEAVEGAME" );
    // DEBUG_Print( data );

    // 2 bytes					-> Header
    // 2 bytes					-> Length
    // 4 bytes					-> Reason

    if (ValidateLength(data) && data.size() >= 8)
      return ByteArrayToUInt32(data, false, 4);                     

    return 0;
  }

  bool RECEIVE_W3GS_GAMELOADED_SELF(const std::vector<uint8_t>& data)
  {
    // DEBUG_Print( "RECEIVED W3GS_GAMELOADED_SELF" );
    // DEBUG_Print( data );

    // 2 bytes					-> Header
    // 2 bytes					-> Length

    if (ValidateLength(data))
      return true;

    return false;
  }

  CIncomingAction RECEIVE_W3GS_OUTGOING_ACTION(const std::vector<uint8_t>& data, uint8_t UID)
  {
    // DEBUG_Print( "RECEIVED W3GS_OUTGOING_ACTION" );
    // DEBUG_Print( data );

    // 2 bytes                -> Header
    // 2 bytes                -> Length
    // 4 bytes                -> CRC
    // remainder of packet		-> Action

    /*const std::array<uint8_t, 4> CRC;
    copy_n(data.begin() + 4, 4, CRC.begin());*/
    std::vector<uint8_t> action = std::vector<uint8_t>(begin(data) + 8, end(data));
    return CIncomingAction(UID, action);
  }

  uint32_t RECEIVE_W3GS_OUTGOING_KEEPALIVE(const std::vector<uint8_t>& data)
  {
    // DEBUG_Print( "RECEIVED W3GS_OUTGOING_KEEPALIVE" );
    // DEBUG_Print( data );

    // 2 bytes					-> Header
    // 2 bytes					-> Length
    // 1 byte           -> ???
    // 4 bytes					-> CheckSum

    if (ValidateLength(data) && data.size() == 9)
      return ByteArrayToUInt32(data, false, 5);

    return 0;
  }

  CIncomingChatMessage RECEIVE_W3GS_CHAT_TO_HOST(const std::vector<uint8_t>& data)
  {
    // DEBUG_Print( "RECEIVED W3GS_CHAT_TO_HOST" );
    // DEBUG_Print( data );

    // 2 bytes              -> Header
    // 2 bytes              -> Length
    // 1 byte               -> Total
    // for( 1 .. Total )
    //		1 byte            -> ToUID
    // 1 byte               -> FromUID
    // 1 byte               -> Flag
    // if( Flag == 16 )
    //		null term string	-> Message
    // elseif( Flag == 17 )
    //		1 byte            -> Team
    // elseif( Flag == 18 )
    //		1 byte            -> Color
    // elseif( Flag == 19 )
    //		1 byte            -> Race
    // elseif( Flag == 20 )
    //		1 byte            -> Handicap
    // elseif( Flag == 32 )
    //		4 bytes           -> ExtraFlags
    //		null term string	-> Message

    if (ValidateLength(data))
    {
      uint32_t      i     = 5;
      const uint8_t Total = data[4];

      if (Total > 0 && data.size() >= i + Total)
      {
        const std::vector<uint8_t> ToUIDs = std::vector<uint8_t>(begin(data) + i, begin(data) + i + Total);
        i += Total;
        const uint8_t FromUID = data[i];
        const uint8_t Flag    = data[i + 1];
        i += 2;

        if (Flag == GameProtocol::Magic::ChatType::CHAT_LOBBY && data.size() >= i + 1) { // 16
          // chat message

          const std::vector<uint8_t> Message = ExtractCString(data, i);
          return CIncomingChatMessage(FromUID, ToUIDs, Flag, string(begin(Message), end(Message)));
        } else if ((Flag >= GameProtocol::Magic::ChatType::REQUEST_TEAM && Flag <= GameProtocol::Magic::ChatType::REQUEST_HANDICAP) && data.size() >= i + 1) { // 17-20
          // team/colour/race/handicap change request 

          const uint8_t Byte = data[i];
          return CIncomingChatMessage(FromUID, ToUIDs, Flag, Byte);
        } else if (Flag == GameProtocol::Magic::ChatType::CHAT_IN_GAME && data.size() >= i + 5) { // 32
          // chat message with extra flags

          const uint32_t ExtraFlags = ByteArrayToUInt32(data, false, i);
          const std::vector<uint8_t> Message = ExtractCString(data, i + 4);
          return CIncomingChatMessage(FromUID, ToUIDs, Flag, string(begin(Message), end(Message)), ExtraFlags);
        }
      }
    }

    return CIncomingChatMessage();
  }

  CIncomingMapFileSize RECEIVE_W3GS_MAPSIZE(const std::vector<uint8_t>& data)
  {
    // DEBUG_Print( "RECEIVED W3GS_MAPSIZE" );
    // DEBUG_Print( data );

    // 2 bytes					-> Header
    // 2 bytes					-> Length
    // 4 bytes					-> ???
    // 1 byte           -> SizeFlag (1 = have map, 3 = continue download)
    // 4 bytes					-> MapSize

    if (ValidateLength(data) && data.size() >= 13)
      return CIncomingMapFileSize(data[8], ByteArrayToUInt32(data, false, 9));

    return CIncomingMapFileSize();
  }

  uint32_t RECEIVE_W3GS_PONG_TO_HOST(const std::vector<uint8_t>& data)
  {
    // DEBUG_Print( "RECEIVED W3GS_PONG_TO_HOST" );
    // DEBUG_Print( data );

    // 2 bytes					-> Header
    // 2 bytes					-> Length
    // 4 bytes					-> Pong

    // the pong value is just a copy of whatever was sent in SEND_W3GS_PING_FROM_HOST which was GetTicks( ) at the time of sending
    // so as long as we trust that the client isn't trying to fake us out and mess with the pong value we can find the round trip time by simple subtraction
    // (the subtraction is done elsewhere because the very first pong value seems to be 1 and we want to discard that one)

    if (ValidateLength(data) && data.size() >= 8)
      return ByteArrayToUInt32(data, false, 4);

    return 1;
  }

  ////////////////////
  // SEND FUNCTIONS //
  ////////////////////

  std::vector<uint8_t> SEND_W3GS_PING_FROM_HOST(const int64_t ticks)
  {
    std::vector<uint8_t> packet = {GameProtocol::Magic::W3GS_HEADER, GameProtocol::Magic::PING_FROM_HOST, 8, 0};
    AppendByteArray(packet, ticks, false); // ping value
    return packet;
  }

  std::vector<uint8_t> SEND_W3GS_REQJOIN(const uint32_t HostCounter, const uint32_t EntryKey, const std::string& Name)
  {
    const uint8_t              Zeros[]  = {0, 0, 0, 0};
    std::vector<uint8_t> packet;
    packet.push_back(GameProtocol::Magic::W3GS_HEADER);                    // W3GS header constant
    packet.push_back(GameProtocol::Magic::REQJOIN);            // W3GS_REQJOIN
    packet.push_back(0);                                       // packet length will be assigned later
    packet.push_back(0);                                       // packet length will be assigned later
    AppendByteArray(packet, HostCounter, false);               // game host counter
    AppendByteArray(packet, EntryKey, false);                  // game entry key
    packet.push_back(0);                                       //
    AppendByteArray(packet, static_cast<uint16_t>(6112), false);  
    AppendByteArray(packet, Zeros, 4);
    AppendByteArrayString(packet, Name, true);
    AppendByteArray(packet, Zeros, 4);                          // ???
    AppendByteArray(packet, static_cast<uint16_t>(6112), true); //  
    AppendByteArray(packet, Zeros, 4);                          // ???
    AppendByteArray(packet, Zeros, 4);                          // ???
    AppendByteArray(packet, Zeros, 4);                          // ???
    AssignLength(packet);
    return packet;
  }

  std::vector<uint8_t> SEND_W3GS_SLOTINFOJOIN(uint8_t UID, const std::array<uint8_t, 2>& port, const std::array<uint8_t, 4>& externalIP, const vector<CGameSlot>& slots, uint32_t randomSeed, uint8_t layoutStyle, uint8_t playerSlots)
  {
    std::vector<uint8_t> packet;

    const uint8_t              Zeros[]  = {0, 0, 0, 0};
    const std::vector<uint8_t> SlotInfo = EncodeSlotInfo(slots, randomSeed, layoutStyle, playerSlots);
    packet.push_back(GameProtocol::Magic::W3GS_HEADER);                    // W3GS header constant
    packet.push_back(GameProtocol::Magic::SLOTINFOJOIN);       // W3GS_SLOTINFOJOIN
    packet.push_back(0);                                       // packet length will be assigned later
    packet.push_back(0);                                       // packet length will be assigned later
    AppendByteArray(packet, static_cast<uint16_t>(SlotInfo.size()), false); // SlotInfo length
    AppendByteArrayFast(packet, SlotInfo);                     // SlotInfo
    packet.push_back(UID);                                     // UID
    packet.push_back(2);                                       // AF_INET
    packet.push_back(0);                                       // AF_INET continued...
    AppendByteArrayFast(packet, port);                             // port
    AppendByteArrayFast(packet, externalIP);                   // external IP
    AppendByteArray(packet, Zeros, 4);                         // ???
    AppendByteArray(packet, Zeros, 4);                         // ???
    AssignLength(packet);

    return packet;
  }

  std::vector<uint8_t> SEND_W3GS_REJECTJOIN(uint32_t reason)
  {
    std::vector<uint8_t> packet = {GameProtocol::Magic::W3GS_HEADER, GameProtocol::Magic::REJECTJOIN, 8, 0};
    AppendByteArray(packet, reason, false); // reason
    return packet;
  }

  std::vector<uint8_t> SEND_W3GS_PLAYERINFO(const Version& version, uint8_t UID, const string& name, const std::array<uint8_t, 4>& externalIP, const std::array<uint8_t, 4>& internalIP)
  {
    if (name.empty() || name.size() > MAX_PLAYER_NAME_SIZE) {
      Print("[GAMEPROTO] Invalid player name");
      return std::vector<uint8_t>();
    }

    std::vector<uint8_t> packet;

    const uint8_t PlayerJoinCounter[] = {2, 0, 0, 0};
    const uint8_t Zeros[]             = {0, 0, 0, 0};

    packet.push_back(GameProtocol::Magic::W3GS_HEADER);                         // W3GS header constant
    packet.push_back(GameProtocol::Magic::PLAYERINFO);              // W3GS_PLAYERINFO
    packet.push_back(0);                                            // packet length will be assigned later
    packet.push_back(0);                                            // packet length will be assigned later
    AppendByteArray(packet, PlayerJoinCounter, 4);                  // player join counter
    packet.push_back(UID);                                          // UID
    AppendByteArrayString(packet, name, true);                      // player name
    if (version >= GAMEVER(1u, 31u)) {
      packet.push_back(2);                                          // ???
      packet.push_back(0);                                          // ???
    } else {
      packet.push_back(1);                                          // ???
    }
    packet.push_back(0);                                            // ???
    packet.push_back(2);                                            // AF_INET
    packet.push_back(0);                                            // AF_INET continued...
    packet.push_back(0);                                            // port
    packet.push_back(0);                                            // port continued...
    AppendByteArrayFast(packet, externalIP);                        // external IP
    AppendByteArray(packet, Zeros, 4);                              // ???
    AppendByteArray(packet, Zeros, 4);                              // ???
    packet.push_back(2);                                            // AF_INET
    packet.push_back(0);                                            // AF_INET continued...
    packet.push_back(0);                                            // port
    packet.push_back(0);                                            // port continued...
    AppendByteArrayFast(packet, internalIP);                        // internal IP
    AppendByteArray(packet, Zeros, 4);                              // ???
    AppendByteArray(packet, Zeros, 4);                              // ???
    AssignLength(packet);

    return packet;
  }

  std::vector<uint8_t> SEND_W3GS_PLAYERINFO_EXCLUDE_IP(const Version& version, uint8_t UID, const string& name)
  {
    array<uint8_t, 4> Zeros = {0, 0, 0, 0};
    return SEND_W3GS_PLAYERINFO(version, UID, name, Zeros, Zeros);
  }

  std::vector<uint8_t> SEND_W3GS_PLAYERLEAVE_OTHERS(uint8_t UID, uint32_t leftCode)
  {
    if (UID != 255)
    {
      std::vector<uint8_t> packet = {GameProtocol::Magic::W3GS_HEADER, GameProtocol::Magic::PLAYERLEAVE_OTHERS, 9, 0, UID};
      AppendByteArray(packet, leftCode, false); // left code (see PLAYERLEAVE_ constants in game_protocol.h)
      return packet;
    }

    Print("[GAMEPROTO] invalid parameters passed to SEND_W3GS_PLAYERLEAVE_OTHERS");
    return std::vector<uint8_t>();
  }

  std::vector<uint8_t> SEND_W3GS_GAMELOADED_OTHERS(uint8_t UID)
  {
    if (UID != 255)
      return std::vector<uint8_t>{GameProtocol::Magic::W3GS_HEADER, GameProtocol::Magic::GAMELOADED_OTHERS, 5, 0, UID};

    Print("[GAMEPROTO] invalid parameters passed to SEND_W3GS_GAMELOADED_OTHERS");

    return std::vector<uint8_t>();
  }

  std::vector<uint8_t> SEND_W3GS_SLOTINFO(const vector<CGameSlot>& slots, uint32_t randomSeed, uint8_t layoutStyle, uint8_t playerSlots)
  {
    const std::vector<uint8_t> SlotInfo     = EncodeSlotInfo(slots, randomSeed, layoutStyle, playerSlots);
    const uint16_t             SlotInfoSize = static_cast<uint16_t>(SlotInfo.size());

    std::vector<uint8_t> packet = {GameProtocol::Magic::W3GS_HEADER, GameProtocol::Magic::SLOTINFO, 0, 0};
    AppendByteArray(packet, SlotInfoSize, false); // SlotInfo length
    AppendByteArrayFast(packet, SlotInfo);        // SlotInfo
    AssignLength(packet);
    return packet;
  }

  std::vector<uint8_t> SEND_W3GS_COUNTDOWN_START()
  {
    return std::vector<uint8_t>{GameProtocol::Magic::W3GS_HEADER, GameProtocol::Magic::COUNTDOWN_START, 4, 0};
  }

  std::vector<uint8_t> SEND_W3GS_COUNTDOWN_END()
  {
    return std::vector<uint8_t>{GameProtocol::Magic::W3GS_HEADER, GameProtocol::Magic::COUNTDOWN_END, 4, 0};
  }

  std::vector<uint8_t> SEND_W3GS_EMPTY_ACTIONS(uint32_t count)
  {
    std::vector<uint8_t> actions;
    actions.reserve(6 * count);
    while (count--) {
      AppendByteArrayFast(actions, GetEmptyAction());
    }
    return actions;
  }

  std::vector<uint8_t> SEND_W3GS_INCOMING_ACTION(const ActionQueue& actions, uint16_t sendInterval)
  {
    std::vector<uint8_t> packet = {GameProtocol::Magic::W3GS_HEADER, GameProtocol::Magic::INCOMING_ACTION, 0, 0};
    AppendByteArray(packet, sendInterval, false); // send interval

    // create subpacket

    if (!actions.empty())
    {
      std::vector<uint8_t> subpacket;
      auto it = actions.begin();
      while (it != actions.end()) {
        subpacket.push_back(it->GetUID());
        AppendByteArray(subpacket, static_cast<uint16_t>(it->GetImmutableAction().size()), false);
        AppendByteArrayFast(subpacket, it->GetImmutableAction());
        ++it;
      }

      // calculate crc (we only care about the lower 2 bytes though)
      uint32_t crc32 = CRC32::CalculateCRC((uint8_t*)string(begin(subpacket), end(subpacket)).c_str(), subpacket.size());

      // finish subpacket
      AppendByteArray(packet, static_cast<uint16_t>(crc32 & 0xFFFF), false);      // crc
      AppendByteArrayFast(packet, subpacket);                                     // subpacket
    }

    AssignLength(packet);
    return packet;
  }

  std::vector<uint8_t> SEND_W3GS_CHAT_FROM_HOST_IN_GAME_ATOMIC(uint8_t fromUID, const std::vector<uint8_t>& toUIDs, uint8_t flag, const uint32_t flagExtra, string_view message)
  {
    vector<uint8_t> packet;
    uint16_t length = static_cast<uint16_t>(12 + toUIDs.size() + message.size());
    packet.reserve(length);
    packet.push_back(GameProtocol::Magic::W3GS_HEADER);
    packet.push_back(GameProtocol::Magic::CHAT_FROM_HOST);
    AppendByteArray(packet, length, false);
    packet.push_back(static_cast<uint8_t>(toUIDs.size()));
    AppendByteArrayFast(packet, toUIDs);    // receivers
    packet.push_back(fromUID);              // sender
    packet.push_back(flag);                 // flag
    AppendByteArray(packet, flagExtra, false); // extra flag
    AppendByteArrayString(packet, message, true);   // message
    AssignLength(packet);
    return packet;
  }

  std::vector<uint8_t> SEND_W3GS_CHAT_FROM_HOST_LOBBY_ATOMIC(uint8_t fromUID, const std::vector<uint8_t>& toUIDs, uint8_t flag, string_view message)
  {
    vector<uint8_t> packet;
    uint16_t length = static_cast<uint16_t>(8 + toUIDs.size() + message.size());
    packet.reserve(length);
    packet.push_back(GameProtocol::Magic::W3GS_HEADER);
    packet.push_back(GameProtocol::Magic::CHAT_FROM_HOST);
    AppendByteArray(packet, length, false);
    packet.push_back(static_cast<uint8_t>(toUIDs.size()));
    AppendByteArrayFast(packet, toUIDs);    // receivers
    packet.push_back(fromUID);              // sender
    packet.push_back(flag);                 // flag
    AppendByteArrayString(packet, message, true);   // message
    AssignLength(packet);
    return packet;
  }

  std::vector<uint8_t> SEND_W3GS_CHAT_FROM_HOST_IN_GAME(uint8_t fromUID, const std::vector<uint8_t>& toUIDs, uint8_t flag, const uint32_t flagExtra, string_view message)
  {
    if (toUIDs.empty() || message.empty() || MAX_SLOTS_MODERN < toUIDs.size()) {
      Print("[GAMEPROTO] invalid parameters passed to SEND_W3GS_CHAT_FROM_HOST_IN_GAME");
      return vector<uint8_t>();
    }

    vector<uint8_t> packet;
    packet.reserve(((message.size() + (MAX_IN_GAME_CHAT_SIZE - 1)) / MAX_IN_GAME_CHAT_SIZE) * (12 + toUIDs.size()) + message.size());

    while (message.size() > MAX_IN_GAME_CHAT_SIZE) {
      string_view chunk = message.substr(0, MAX_IN_GAME_CHAT_SIZE);
      AppendByteArrayFast(packet, SEND_W3GS_CHAT_FROM_HOST_IN_GAME_ATOMIC(fromUID, toUIDs, flag, flagExtra, chunk));
      message.remove_prefix(MAX_IN_GAME_CHAT_SIZE);
    }
    if (!message.empty()) {
      AppendByteArrayFast(packet, SEND_W3GS_CHAT_FROM_HOST_IN_GAME_ATOMIC(fromUID, toUIDs, flag, flagExtra, message));
    }
    return packet;
  }

  std::vector<uint8_t> SEND_W3GS_CHAT_FROM_HOST_LOBBY(uint8_t fromUID, const std::vector<uint8_t>& toUIDs, uint8_t flag, string_view message)
  {
    if (toUIDs.empty() || message.empty() || MAX_SLOTS_MODERN < toUIDs.size()) {
      Print("[GAMEPROTO] invalid parameters passed to SEND_W3GS_CHAT_FROM_HOST_LOBBY");
      return vector<uint8_t>();
    }

    vector<uint8_t> packet;
    packet.reserve(((message.size() + (MAX_LOBBY_CHAT_SIZE - 1)) / MAX_LOBBY_CHAT_SIZE) * (8 + toUIDs.size()) + message.size());

    while (message.size() > MAX_LOBBY_CHAT_SIZE) {
      string_view chunk = message.substr(0, MAX_LOBBY_CHAT_SIZE);
      AppendByteArrayFast(packet, SEND_W3GS_CHAT_FROM_HOST_LOBBY_ATOMIC(fromUID, toUIDs, flag, chunk));
      message.remove_prefix(MAX_LOBBY_CHAT_SIZE);
    }
    if (!message.empty()) {
      AppendByteArrayFast(packet, SEND_W3GS_CHAT_FROM_HOST_LOBBY_ATOMIC(fromUID, toUIDs, flag, message));
    }
    return packet;
  }

  std::vector<uint8_t> SEND_W3GS_START_LAG(const vector<GameUser::CGameUser*>& users, const int64_t ticks)
  {
    if (users.empty()) {
      Print("[GAMEPROTO] no laggers passed to SEND_W3GS_START_LAG");
      return std::vector<uint8_t>();
    }

    std::vector<uint8_t> packet = {GameProtocol::Magic::W3GS_HEADER, GameProtocol::Magic::START_LAG, 0u, 0u, static_cast<uint8_t>(users.size())};
    for (auto& player : users) {
      packet.push_back((player)->GetUID());
      AppendByteArray(packet, ticks - player->GetStartedLaggingTicks(), false);
    }

    AssignLength(packet);
    return packet;
  }

  std::vector<uint8_t> SEND_W3GS_STOP_LAG(const GameUser::CGameUser* user, const int64_t ticks)
  {
    std::vector<uint8_t> packet = {GameProtocol::Magic::W3GS_HEADER, GameProtocol::Magic::STOP_LAG, 9, 0, user->GetUID()};
    AppendByteArray(packet, ticks - user->GetStartedLaggingTicks(), false);
    return packet;
  }

  std::vector<uint8_t> SEND_W3GS_GAMEINFO(const bool isExpansion, const Version& war3Version, const uint32_t mapGameType, const uint32_t gameFlags, const std::array<uint8_t, 2>& mapWidth, const std::array<uint8_t, 2>& mapHeight, const string& gameName, const string& hostName, uint32_t upTime, const string& mapPath, const std::array<uint8_t, 4>& mapBlizzHash, uint32_t slotsTotal, uint32_t slotsAvailableOff, uint16_t port, uint32_t hostCounter, uint32_t entryKey)
  {
    if (gameName.empty() || hostName.empty() || mapPath.empty()) {
      Print("[GAMEPROTO] name/path not passed to SEND_W3GS_GAMEINFO");
      return std::vector<uint8_t>();
    }
    const uint8_t Unknown2[] = {1, 0, 0, 0};
    const uint8_t version4[] = {war3Version.second, 0, 0, 0};

    // make the stat string

    GameStat gameStat(gameFlags, ByteArrayToUInt16(mapWidth, false), ByteArrayToUInt16(mapHeight, false), mapPath, hostName, mapBlizzHash, nullopt);
    vector<uint8_t> statString = gameStat.Encode();

    // make the rest of the packet

    std::vector<uint8_t> packet = {GameProtocol::Magic::W3GS_HEADER, GameProtocol::Magic::GAMEINFO, 0, 0};
    if (isExpansion) {
      AppendByteArray(packet, reinterpret_cast<const uint8_t*>(ProductID_TFT), 4);                     // Product ID (TFT)
    } else {
      AppendByteArray(packet, reinterpret_cast<const uint8_t*>(ProductID_ROC), 4);                     // Product ID (TFT)
    }
    AppendByteArray(packet, version4, 4);
    AppendByteArray(packet, hostCounter, false);             // Host Counter
    AppendByteArray(packet, entryKey, false);                // Entry Key
    AppendByteArrayString(packet, gameName, true);                   // Game Name
    packet.push_back(0);                                     // ??? (maybe game password)
    AppendByteArrayFast(packet, statString);                 // Stat String
    packet.push_back(0);                                     // Stat String null terminator (the stat string is encoded to remove all even numbers i.e. zeros)
    AppendByteArray(packet, slotsTotal, false);              // Slots Total
    AppendByteArray(packet, mapGameType, false);             // Game Type
    AppendByteArray(packet, Unknown2, 4);                    // ???
    //AppendByteArray(packet, slotsTaken, false);            // Slots Taken again??
    AppendByteArray(packet, slotsAvailableOff, false);       // Slots Available off-by-one
    AppendByteArray(packet, upTime, false);                  // time since creation
    AppendByteArray(packet, port, false);                    // port
    AssignLength(packet);
    return packet;
  }

  std::vector<uint8_t> SEND_W3GS_GAMEINFO_TEMPLATE(uint16_t* gameVersionOffset, uint16_t* dynamicInfoOffset, const bool isExpansion, const uint32_t mapGameType, const uint32_t mapFlags, const std::array<uint8_t, 2>& mapWidth, const std::array<uint8_t, 2>& mapHeight, const string& gameName, const string& hostName, const string& mapPath, const std::array<uint8_t, 4>& mapBlizzHash, uint32_t slotsTotal, uint32_t hostCounter, uint32_t entryKey)
  {
    if (gameName.empty() || hostName.empty() || mapPath.empty()) {
      Print("[GAMEPROTO] name/path not passed to SEND_W3GS_GAMEINFO");
      return std::vector<uint8_t>();
    }

    const uint8_t Unknown2[] = {1, 0, 0, 0};
    const uint8_t Zeros[] = {0, 0, 0, 0};

    // make the stat string

    std::vector<uint8_t> StatString;
    AppendByteArray(StatString, mapFlags, false);
    StatString.push_back(0);
    AppendByteArrayFast(StatString, mapWidth);
    AppendByteArrayFast(StatString, mapHeight);
    AppendByteArrayFast(StatString, mapBlizzHash);
    AppendByteArrayString(StatString, mapPath, true);
    AppendByteArrayString(StatString, hostName, true);
    StatString.push_back(0);
    StatString = EncodeStatString(StatString);

    // make the rest of the packet

    std::vector<uint8_t> packet = {GameProtocol::Magic::W3GS_HEADER, GameProtocol::Magic::GAMEINFO, 0, 0};
    if (isExpansion) {
      AppendByteArray(packet, reinterpret_cast<const uint8_t*>(ProductID_TFT), 4);                     // Product ID (TFT)
    } else {
      AppendByteArray(packet, reinterpret_cast<const uint8_t*>(ProductID_ROC), 4);                     // Product ID (TFT)
    }
    *gameVersionOffset = static_cast<uint16_t>(packet.size());       // Game version
    AppendByteArray(packet, Zeros, 4);
    AppendByteArray(packet, hostCounter, false);                     // Host Counter
    AppendByteArray(packet, entryKey, false);                        // Entry Key
    AppendByteArrayString(packet, gameName, true);                   // Game Name
    packet.push_back(0);                                             // ??? (maybe game password)
    AppendByteArrayFast(packet, StatString);                         // Stat String
    packet.push_back(0);                                             // Stat String null terminator (the stat string is encoded to remove all even numbers i.e. zeros)
    AppendByteArray(packet, slotsTotal, false);                      // Slots Total
    AppendByteArray(packet, mapGameType, false);                     // Game Type (saved?)
    AppendByteArray(packet, Unknown2, 4);                            // ???
    *dynamicInfoOffset = static_cast<uint16_t>(packet.size());       // TCP port
    AppendByteArray(packet, Zeros, 4);                               // Slots Available off-by-one
    AppendByteArray(packet, Zeros, 4);                               // time since creation
    packet.push_back(0);
    packet.push_back(0);
    AssignLength(packet);
    return packet;
  }

  std::vector<uint8_t> SEND_W3GS_CREATEGAME(const bool isExpansion, const Version& war3Version, const uint32_t hostCounter)
  {
    const uint8_t version4[] = {war3Version.second, 0, 0, 0};

    std::vector<uint8_t> packet = {GameProtocol::Magic::W3GS_HEADER, GameProtocol::Magic::CREATEGAME, 16, 0};
    if (isExpansion) {
      AppendByteArray(packet, reinterpret_cast<const uint8_t*>(ProductID_TFT), 4);                     // Product ID (TFT)
    } else {
      AppendByteArray(packet, reinterpret_cast<const uint8_t*>(ProductID_ROC), 4);                     // Product ID (TFT)
    }
    AppendByteArray(packet, version4, 4);
    AppendByteArray(packet, hostCounter, false); // Host Counter
    return packet;
  }

  std::vector<uint8_t> SEND_W3GS_REFRESHGAME(const uint32_t hostCounter, const uint32_t players, const uint32_t playerSlots)
  {
    std::vector<uint8_t> packet = {GameProtocol::Magic::W3GS_HEADER, GameProtocol::Magic::REFRESHGAME, 16, 0};
    AppendByteArray(packet, hostCounter, false); // Host Counter
    AppendByteArray(packet, players, false);     // Players
    AppendByteArray(packet, playerSlots, false); // Player Slots
    return packet;
  }

  std::vector<uint8_t> SEND_W3GS_DECREATEGAME(const uint32_t hostCounter)
  {
    std::vector<uint8_t> packet = {GameProtocol::Magic::W3GS_HEADER, GameProtocol::Magic::DECREATEGAME, 8, 0};
    AppendByteArray(packet, hostCounter, false); // Host Counter
    return packet;
  }

  std::vector<uint8_t> SEND_W3GS_MAPCHECK(const string& mapPath, const uint32_t mapSize, const std::array<uint8_t, 4>& mapCRC32, const std::array<uint8_t, 4>& mapScriptsHashBlizz, const std::optional<array<uint8_t, 20>>& mapScriptsHashSHA1)
  {
    if (mapPath.empty()) {
      Print("[GAMEPROTO] invalid parameters passed to SEND_W3GS_MAPCHECK");
      return std::vector<uint8_t>();  
    }

    std::vector<uint8_t> packet = {GameProtocol::Magic::W3GS_HEADER, GameProtocol::Magic::MAPCHECK, 0, 0, 1, 0, 0, 0};
    AppendByteArrayString(packet, mapPath, true); // <map.path>
    AppendByteArray(packet, mapSize, false); // <map.size>
    AppendByteArrayFast(packet, mapCRC32); // <map.file_hash.crc32>
    AppendByteArrayFast(packet, mapScriptsHashBlizz);  // <map.scripts_hash.blizz>
    if (mapScriptsHashSHA1.has_value()) {
      AppendByteArrayFast(packet, *mapScriptsHashSHA1); // <map.scripts_hash.sha1>
    }
    AssignLength(packet);
    return packet;
  }

  std::vector<uint8_t> SEND_W3GS_STARTDOWNLOAD(uint8_t fromUID)
  {
    return std::vector<uint8_t>{GameProtocol::Magic::W3GS_HEADER, GameProtocol::Magic::STARTDOWNLOAD, 9, 0, 1, 0, 0, 0, fromUID};
  }

  std::vector<uint8_t> SEND_W3GS_MAPPART(uint8_t fromUID, uint8_t toUID, size_t start_abs /* offset in map file */, const FileChunkTransient& mapFileChunk)
  {
    if (mapFileChunk.start > start_abs || !mapFileChunk.bytes) {
      Print("[GAMEPROTO] invalid parameters passed to SEND_W3GS_MAPPART (L707)");
      return std::vector<uint8_t>();
    }

    size_t max_end_abs = mapFileChunk.start + mapFileChunk.bytes->size();
    if (max_end_abs <= start_abs) {
      Print("[GAMEPROTO] invalid parameters passed to SEND_W3GS_MAPPART (L707)");
      return std::vector<uint8_t>();
    }

    // calculate end position (don't send more than 1442 map bytes in one packet)
    size_t end_abs = start_abs + 1442;
    if (max_end_abs < end_abs) {
      end_abs = max_end_abs;
    }

    if (end_abs < start_abs) {
      Print("[GAMEPROTO] invalid parameters passed to SEND_W3GS_MAPPART (L718)");
      return std::vector<uint8_t>();
    }

    // start_rel, end_rel are offsets relative to the cached chunk
    size_t start_rel = start_abs - mapFileChunk.start;
    size_t end_rel = end_abs - mapFileChunk.start;

    std::vector<uint8_t> packet = {GameProtocol::Magic::W3GS_HEADER, GameProtocol::Magic::MAPPART, 0, 0, toUID, fromUID, 1, 0, 0, 0}; // 10 bytes
    AppendByteArray(packet, static_cast<uint32_t>(start_abs), false); // start position, 4 bytes

    // calculate crc

    const std::vector<uint8_t> crc32 = CreateByteArray(CRC32::CalculateCRC(mapFileChunk.bytes->data() + start_rel, (uint32_t)(end_rel - start_rel)), false);
    AppendByteArrayFast(packet, crc32);

    // map data

    const std::vector<uint8_t> data = CreateByteArray(mapFileChunk.bytes->data() + start_rel, (uint32_t)(end_rel - start_rel));
    AppendByteArrayFast(packet, data);
    AssignLength(packet);
    return packet;
  }

  std::vector<uint8_t> SEND_W3GS_MAPPART(uint8_t fromUID, uint8_t toUID, size_t start, const SharedByteArray& mapFileContents)
  {
    if (!mapFileContents || mapFileContents->size() < start) {
      Print("[GAMEPROTO] invalid parameters passed to SEND_W3GS_MAPPART");
      return std::vector<uint8_t>();
    }

    std::vector<uint8_t> packet = {GameProtocol::Magic::W3GS_HEADER, GameProtocol::Magic::MAPPART, 0, 0, toUID, fromUID, 1, 0, 0, 0};
    AppendByteArray(packet, static_cast<uint32_t>(start), false); // start position

    // calculate end position (don't send more than 1442 map bytes in one packet)

    size_t end = start + 1442;

    if (end > mapFileContents->size() || end < start)
      end = mapFileContents->size();

    // calculate crc

    const std::vector<uint8_t> crc32 = CreateByteArray(CRC32::CalculateCRC(mapFileContents->data() + (size_t)(start), (uint32_t)(end - start)), false);
    AppendByteArrayFast(packet, crc32);

    // map data

    const std::vector<uint8_t> data = CreateByteArray(mapFileContents->data() + (size_t)(start), (uint32_t)(end - start));
    AppendByteArrayFast(packet, data);
    AssignLength(packet);
    return packet;
  }

  std::vector<uint8_t> SEND_W3GS_INCOMING_ACTION2(const ActionQueue& actions)
  {
    std::vector<uint8_t> packet = {GameProtocol::Magic::W3GS_HEADER, GameProtocol::Magic::INCOMING_ACTION2, 0, 0, 0, 0};

    // create subpacket

    if (!actions.empty())
    {
      std::vector<uint8_t> subpacket;
      auto it = actions.begin();
      while (it != actions.end()) {
        subpacket.push_back(it->GetUID());
        AppendByteArray(subpacket, static_cast<uint16_t>(it->GetImmutableAction().size()), false);
        AppendByteArrayFast(subpacket, it->GetImmutableAction());
        ++it;
      }

      // calculate crc (we only care about the lower 2 bytes though)
      uint32_t crc32 = CRC32::CalculateCRC((uint8_t*)string(begin(subpacket), end(subpacket)).c_str(), subpacket.size());

      // finish subpacket
      AppendByteArray(packet, static_cast<uint16_t>(crc32 & 0xFFFF), false);      // crc
      AppendByteArrayFast(packet, subpacket);                                     // subpacket
    }

    AssignLength(packet);
    return packet;
  }

  /////////////////////
  // OTHER FUNCTIONS //
  /////////////////////

  std::vector<uint8_t> EncodeSlotInfo(const vector<CGameSlot>& slots, uint32_t randomSeed, uint8_t layoutStyle, uint8_t playerSlots)
  {
    std::vector<uint8_t> slotInfo;
    slotInfo.reserve(7 + 9 * slots.size());
    slotInfo.push_back(static_cast<uint8_t>(slots.size())); // number of slots

    for (auto& slot : slots) {
      AppendByteArrayFast(slotInfo, slot.GetProtocolArray());
    }

    AppendByteArray(slotInfo, randomSeed, false); // random seed
    slotInfo.push_back(layoutStyle);              // LayoutStyle (0 = melee, 1 = custom forces, 3 = custom forces + fixed player settings)
    slotInfo.push_back(playerSlots);              // number of player slots (non observer)
    return slotInfo;
  }

  vector<uint8_t> EmptyAction = {GameProtocol::Magic::W3GS_HEADER, GameProtocol::Magic::INCOMING_ACTION, 6, 0, 0, 0};

  // Some actions have variable sizes because they contain either
  // A. One or more null-terminated strings:
  //    - 0x06 ACTION_SAVE
  //    - 0x60 ACTION_CHAT_TRIGGER
  //    - 0x6B ACTION_GAME_CACHE_INT
  //    - 0x6C ACTION_GAME_CACHE_REAL
  //    - 0x6D ACTION_GAME_CACHE_BOOL
  //    - 0x6E ACTION_GAME_CACHE_UNIT
  //    - 0x6F ACTION_GAME_CACHE_STRING
  //    - 0x78 ACTION_SYNCHRONIZE
  // B. References to a variable amount of objects:
  //    - 0x16 ACTION_SELECTION - Size is 4+8n, n is the second byte after and excluding the action type
  //    - 0x17 ACTION_GROUP_HOTKEY_ASSIGN - Size is 4+8n, n is the second byte after and excluding the action type
  //    - 0x6E ACTION_GAME_CACHE_UNIT
  //    - 0x77 ACTION_W3API
  // C. Variadic size due to third party plugins:
  //    - 0x50 ACTION_ALLIANCE_SETTINGS - Regular size is 6, but if the next byte is 0xF0, size is ???
  //
  // Variable sizes are signaled by a size of 0xFF

  array<uint8_t, 256> ActionSizes = {
    /* Row     0x00  0x01  0x02  0x03     0x04  0x05  0x06  0x07     0x08  0x09  0x0A  0x0B     0x0C  0x0D  0x0E  0x0F */

    /* 0x00 */ 0x00, 0x01, 0x01, 0x02,    0x01, 0x01, 0xFF, 0x05,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,

    //
    // 1.14a-
    // - 0x19 ACTION_SELECTION_SUBGROUP was 2 bytes
    // - 0x1B ACTION_SELECTION_EVENT was 0x1A
    // - 0x1C ACTION_SELECTION_GROUND_ITEM was 0x1B
    // - 0x1D ACTION_CANCEL_REVIVAL was 0x1C
    // - 0x1C ACTION_CANCEL_TRAINING was 0x1D
    //
    // 1.12-
    // - 0x11 ACTION_ABILITY_TARGET_POINT was 22 bytes
    // - 0x12 ACTION_ABILITY_TARGET_OBJECT was 30 bytes
    // - 0x13 ACTION_GIVE_OR_DROP_ITEM was 38 bytes
    // - 0x14 ACTION_ABILITY_TARGET_FOG was 43 bytes
    // - 0x15 ACTION_ABILITY_TARGET_FOG_HANDLE was 51 bytes
    //

    /* Row     0x10  0x11  0x12  0x13     0x14  0x15  0x16  0x17     0x18  0x19  0x1A  0x1B     0x1C  0x1D  0x1E  0x1F */

    /* 0x10 */ 0x0F, 0x17, 0x1F, 0x27,    0x2C, 0x34, 0xFF, 0xFF,    0x03, 0x0D, 0x01, 0x0A,    0x0A, 0x09, 0x06, 0x00,

    // Cheats (0x21 is debug-mode)
    /* 0x20 */ 0x01, 0x09, 0x01, 0x01,    0x01, 0x01, 0x01, 0x06,    0x06, 0x01, 0x01, 0x01,    0x01, 0x06, 0x05, 0x01,

    // Cheats (unknown length are debug-mode)
    /* 0x30 */ 0x01, 0x01, 0x01, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,

    // Cheats (debug-mode)
    /* 0x40 */ 0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,

    /* Row     0x50  0x51  0x52  0x53     0x54  0x55  0x56  0x57     0x58  0x59  0x5A  0x5B     0x5C  0x5D  0x5E  0x5F */

    /* 0x50 */ 0xFF, 0x0A, 0x00, 0x00,    0x00, 0x00, 0x01, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,


    // Other versions
    // v1.06-
    // - 0x66 ACTION_SKILLTREE was 0x65
    // - 0x67 ACTION_BUILDMENU was 0x66
    // - 0x68 ACTION_MINIMAPSIGNAL was 0x67
    // - 0x69 ACTION_MODAL_CLICK_BTN was 0x68
    // - 0x6A ACTION_MODAL_BTN was 0x69

    /* Row     0x60  0x61  0x62  0x63     0x64  0x65  0x66  0x67     0x68  0x69  0x6A  0x6B     0x6C  0x6D  0x6E  0x6F */

    /* 0x60 */ 0xFF, 0x01, 0x0D, 0x09,    0x09, 0x09, 0x01, 0x01,    0x0D, 0x11, 0x11, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF,

    /* Row     0x70  0x71  0x72  0x73     0x74  0x75  0x76  0x77     0x78  0x79  0x7A  0x7B     0x7C  0x7D  0x7E  0x7F */

    /* 0x70 */ 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0x02, 0x0B, 0xFF,    0xFF, 0xFF, 0x15, 0x11,    0x00, 0x00, 0x00, 0x00,
    /* 0x80 */ 0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,
    /* 0x90 */ 0x00, 0x00, 0x00, 0x00,    0x04, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,
    /* 0xA0 */ 0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,
    /* 0xB0 */ 0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,
    /* 0xC0 */ 0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,
    /* 0xD0 */ 0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,
    /* 0xE0 */ 0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,
    /* 0xF0 */ 0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00
  };

  bitset<256> ActionCountables = InitActionCountables();
}

//
// CIncomingJoinRequest
//

CIncomingJoinRequest::CIncomingJoinRequest()
  : m_Valid(false),
    m_Censored(false),
    m_HostCounter(0),
    m_EntryKey(0)
{
  m_IPv4Internal.fill(0);
  m_Name = m_OriginalName;
}

CIncomingJoinRequest::CIncomingJoinRequest(uint32_t nHostCounter, uint32_t nEntryKey, string nName, std::array<uint8_t, 4> nIPv4Internal)
  : m_Valid(true),
    m_Censored(false),
    m_OriginalName(std::move(nName)),
    m_IPv4Internal(std::move(nIPv4Internal)),
    m_HostCounter(nHostCounter),
    m_EntryKey(nEntryKey)
{
  m_Name = m_OriginalName;
}

CIncomingJoinRequest::~CIncomingJoinRequest() = default;

void CIncomingJoinRequest::UpdateCensored(OnUnsafeNameHandler unsafeNameHandler, const bool pipeConsideredHarmful)
{
  if (unsafeNameHandler == OnUnsafeNameHandler::kNone) {
    return;
  }

  m_Name = CIncomingJoinRequest::CensorName(m_Name, pipeConsideredHarmful);
  m_Censored = m_Name.size() != m_OriginalName.size();
}

string CIncomingJoinRequest::CensorName(const std::string& originalName, const bool pipeConsideredHarmful)
{
  string name = originalName;

  // Note: Do not always ban |, since it's used for so-called barcode names in Battle.net
  unordered_set<char> charsToRemoveAnyWhere = {
    // Characters used in commands
    ',', '@',

    // TAB, LF, CR, FF
    '\t', '\n', '\r', '\f',

    // NULL, beep, BS, ESC, DEL, 
    '\x00', '\x07', '\x08', '\x1B', '\x7F'
  };
  if (pipeConsideredHarmful) {
    charsToRemoveAnyWhere.insert('|');
  }
  unordered_set<char> charsToRemoveConditional = {
    '[', ']'
  };

  // # only needs to be banned from names' start
  // In particular, it must NOT be banned in trailing #\d+ patterns,
  // because they represent Battle Tags
  unordered_set<char> charsToRemoveStart = {'#', ' '};
  unordered_set<char> charsToRemoveEnd = {' ', '.'};

  name.erase(
    std::remove_if(
      name.begin(), name.end(), 
      [&charsToRemoveAnyWhere](const char& c) {
         return charsToRemoveAnyWhere.find(c) != charsToRemoveAnyWhere.end();
      }
    ),
    name.end()
  );

  // Ensure brackets are balanced
  // I'd rather blanket ban them, but they may be in use as clan markers
  {
    bool balancedBrackets = true;
    uint8_t bracketDepth = 0;
    for (char ch : name) {
      if (ch == '[') {
        ++bracketDepth;
      } else if (ch == ']') {
        if (bracketDepth <= 0) {
          balancedBrackets = false;
          break;
        } else {
          --bracketDepth;
        }
      }
    }
    if (!balancedBrackets) {
      name.erase(
        std::remove_if(
          name.begin(), name.end(), 
          [&charsToRemoveConditional](const char& c) {
             return charsToRemoveConditional.find(c) != charsToRemoveConditional.end();
          }
        ),
        name.end()
      );
    }
  }

  // Remove bad leading characters (operators, and whitespace)
  {
    auto it = std::find_if(
     name.begin(), name.end(), 
     [&charsToRemoveStart](const char& c) {
         return charsToRemoveStart.find(c) == charsToRemoveStart.end();
     }
    );
    name.erase(name.begin(), it);
  }

  // Remove bad trailing characters (mainly whitespace)
  {
    auto it = std::find_if(
      name.rbegin(), name.rend(), 
      [&charsToRemoveEnd](const char& c) {
        return charsToRemoveEnd.find(c) == charsToRemoveEnd.end();
      }
    );
    name.erase(it.base(), name.end());
  }

  if (name == "Open" || name == "Closed" || name == "Abrir" || name == "Cerrado") {
    name.clear();
  }

  return name;
}

//
// CIncomingAction
//

CIncomingAction::CIncomingAction()
  : m_Error(false),
    m_UID(0xFF),
    m_Count(1),
    m_Action(vector<uint8_t>{0})
{
}

CIncomingAction::CIncomingAction(uint8_t nUID, vector<uint8_t>& nAction)
  : m_Error(W3GS_ACTION_MAX_PACKET_SIZE < nAction.size()),
    m_UID(nUID),
    m_Count(1),
    m_Action(move(nAction))
{
  if (!m_Error) {
    pair<bool, uint16_t> checkResult = CIncomingAction::CountAPMAtomic(m_Action);
    m_Error = checkResult.first;
    m_Count = checkResult.second;
  }
}

CIncomingAction::CIncomingAction(uint8_t nUID, uint8_t nActionType)
  : m_Error(false),
    m_UID(nUID),
    m_Count(1),
    m_Action(vector<uint8_t>{nActionType})
{
}

CIncomingAction::CIncomingAction(const CIncomingAction& other)
  : m_Error(other.m_Error),
    m_UID(other.m_UID),
    m_Count(other.m_Count),
    m_Action(other.m_Action)
{
}

CIncomingAction::CIncomingAction(CIncomingAction&& other) noexcept
  : m_Error(other.m_Error),
    m_UID(other.m_UID),
    m_Count(other.m_Count),
    m_Action(move(other.m_Action))
{
}

CIncomingAction& CIncomingAction::operator=(CIncomingAction&& other) noexcept
{
  if (this != &other) {
    m_Error = other.m_Error;
    m_UID = other.m_UID;
    m_Count = other.m_Count;
    m_Action = std::move(other.m_Action);
  }
  return *this;
}

CIncomingAction::~CIncomingAction() = default;

uint16_t CIncomingAction::GetUint16LE(const size_t offset) const
{
  return ByteArrayToUInt16(m_Action, false, offset);
}

uint16_t CIncomingAction::GetUint16BE(const size_t offset) const
{
  return ByteArrayToUInt16(m_Action, true, offset);
}

uint32_t CIncomingAction::GetUint32LE(const size_t offset) const
{
  return ByteArrayToUInt32(m_Action, false, offset);
}

uint32_t CIncomingAction::GetUint32BE(const size_t offset) const
{
  return ByteArrayToUInt32(m_Action, true, offset);
}

pair<bool, uint16_t> CIncomingAction::CountAPMAtomic(const vector<uint8_t>& action)
{
  const size_t size = action.size();
  pair<bool, uint16_t> result = make_pair<bool, uint16_t>(false, 0); // <errored, count>
  size_t pos = 0, next = 0;
  uint8_t actionType = 0xFF;
  bool lastWasDeselect = false;
  bool isDeselect = false;
  while (pos < size) {
    actionType = action[pos];
    isDeselect = false;
    if (actionType == ACTION_SELECTION || actionType == ACTION_GROUP_HOTKEY_ASSIGN) {
      if (size < pos + 4 || (actionType == ACTION_SELECTION && action[pos + 1] > ACTION_SELECTION_MODE_REMOVE)) {
        result.first = true;
        break;
      }
    }

    if (actionType == ACTION_W3API && size < pos + 13) {
      result.first = true;
      break;
    }

    if (actionType == ACTION_ALLIANCE_SETTINGS && size < pos + 6) {
      result.first = true;
      break;
    }

    if (GameProtocol::GetActionIsCountable(actionType)) {
      if (actionType == ACTION_SELECTION) {
        isDeselect = action[pos + 1] == ACTION_SELECTION_MODE_REMOVE;
        if (isDeselect || !lastWasDeselect) {
          ++result.second;
        }
      } else {
        ++result.second;
      }
    }

    lastWasDeselect = isDeselect;
    next = GameProtocol::GetNextActionPos(action, pos);
    if (size < next || next == pos) {
      Print("[APMCounter] GetNextActionPos(<" + ByteArrayToHexString(action) + ">, " + to_string(pos) + ") == " + to_string(next));
      result.first = true;
      break;
    }
    pos = next;
  }
  return result;
}

vector<const uint8_t*> CIncomingAction::SplitAtomic() const
{
  vector<const uint8_t*> delimiters;
  const size_t size = m_Action.size();
  uint8_t actionType = 0xFF;
  size_t pos = 0;

  while (pos < size) {
    delimiters.push_back(m_Action.data() + pos);
    actionType = m_Action[pos];
    if (actionType == ACTION_SELECTION || actionType == ACTION_GROUP_HOTKEY_ASSIGN) {
      if (size < pos + 4) {
        break;
      }
    }

    if (actionType == ACTION_W3API && size < pos + 13) {
      break;
    }

    if (actionType == ACTION_ALLIANCE_SETTINGS && size < pos + 6) {
      break;
    }

    size_t next = GameProtocol::GetNextActionPos(m_Action, pos);
    if (next == pos) {
      break;
    }
    pos = next;
  }

  delimiters.push_back(m_Action.data() + size);
  return delimiters;
}

//
// CIncomingChatMessage
//

CIncomingChatMessage::CIncomingChatMessage()
  : m_Valid(false),
    m_Type(GameProtocol::ChatToHostType::CTH_MESSAGE_LOBBY),
    m_Byte(255),
    m_FromUID(0xFF),
    m_Flag(0)
{
}

CIncomingChatMessage::CIncomingChatMessage(uint8_t nFromUID, std::vector<uint8_t> nToUIDs, uint8_t nFlag, string nMessage)
  : m_Valid(true),
    m_Message(std::move(nMessage)),
    m_Type(GameProtocol::ChatToHostType::CTH_MESSAGE_LOBBY),
    m_Byte(255),
    m_FromUID(nFromUID),
    m_Flag(nFlag),
    m_ToUIDs(std::move(nToUIDs))
{
}

CIncomingChatMessage::CIncomingChatMessage(uint8_t nFromUID, std::vector<uint8_t> nToUIDs, uint8_t nFlag, string nMessage, uint32_t nExtraFlags)
  : m_Valid(true),
    m_Message(std::move(nMessage)),
    m_Type(GameProtocol::ChatToHostType::CTH_MESSAGE_INGAME),
    m_Byte(255),
    m_FromUID(nFromUID),
    m_Flag(nFlag),
    m_ExtraFlags(nExtraFlags),
    m_ToUIDs(std::move(nToUIDs))
{
}

CIncomingChatMessage::CIncomingChatMessage(uint8_t nFromUID, std::vector<uint8_t> nToUIDs, uint8_t nFlag, uint8_t nByte)
  : m_Valid(true),
    m_Type(GameProtocol::ChatToHostType::CTH_TEAMCHANGE),
    m_Byte(nByte),
    m_FromUID(nFromUID),
    m_Flag(nFlag),
    m_ToUIDs(std::move(nToUIDs))
{
  switch (nFlag) {
    case GameProtocol::Magic::ChatType::REQUEST_TEAM:
      m_Type = GameProtocol::ChatToHostType::CTH_TEAMCHANGE;
      break;
    case GameProtocol::Magic::ChatType::REQUEST_COLOR:
      m_Type = GameProtocol::ChatToHostType::CTH_COLOURCHANGE;
      break;
    case GameProtocol::Magic::ChatType::REQUEST_RACE:
      m_Type = GameProtocol::ChatToHostType::CTH_RACECHANGE;
      break;
    case GameProtocol::Magic::ChatType::REQUEST_HANDICAP:
      m_Type = GameProtocol::ChatToHostType::CTH_HANDICAPCHANGE;
      break;
  }
}

CIncomingChatMessage::~CIncomingChatMessage() = default;

//
// CIncomingMapFileSize
//

CIncomingMapFileSize::CIncomingMapFileSize()
  : m_Valid(false),
    m_FileSize(0),
    m_Flag(0)
{
}

CIncomingMapFileSize::CIncomingMapFileSize(uint8_t nSizeFlag, uint32_t nMapSize)
  : m_Valid(true),
    m_FileSize(nMapSize),
    m_Flag(nSizeFlag)
{
}

CIncomingMapFileSize::~CIncomingMapFileSize() = default;
